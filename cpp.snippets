# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt


##################################################################
#  My Snippets
################################################################

snippet snipiored "IO redirection" b 

    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif

endsnippet

snippet basic "Basic Code Snippet for CPP" b
#include <iostream>
using namespace std;

$0


int main(){




	return 0;
}
endsnippet


snippet snipcp "Basic Snippet for competitve programming" b
#include <bits/stdc++.h>
using namespace std;

typedef long long int li;
typedef long double ld;
typedef pair<int,int> pi;
typedef priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> MinHeap;


$0


int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif

    int tt;
    cin >> tt;

    while (tt-- > 0)
    {
        
    }

    return 0;
}
endsnippet

snippet snipleet "Basic Snippet for Leetcode" b
#include <bits/stdc++.h>
using namespace std;

typedef long long int li;
typedef long double ld;
typedef pair<int,int> pi;
typedef priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> MinHeap;


$0


int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif

    int tt;
    cin >> tt;

    while (tt-- > 0)
    {
        Solution ob;
        
        
    }

    return 0;
}
endsnippet

snippet sniptree "Binary Tree" b
struct TreeNode{
    int val,ht;
    TreeNode *left,*right;

    TreeNode(int data){
        val=data;
        ht=1;
        left=NULL;
        right=NULL;
    }

};

namespace my{
    int height(TreeNode *node){
        if(node==NULL)return 0;

        int lh,rh;
        lh=height(node->left);
        rh=height(node->right);
        return 1 + max(lh,rh);
    }

    vector<vector<string>>printTree(TreeNode *root){

        int m,n;
        // m is number of columns
        // n is number of rows
        int rootHt = height(root);
        m = rootHt;
        n = (1 << rootHt)-1;
        vector<vector<string>>res(m,vector<string>(n));


        queue<pair<TreeNode*,pair<int,int>>>q;
        q.push({root,  { 0, (n-1)/2 }  });

        while(!q.empty())
        {
            int sz=q.size();
            for(int i=0;i<sz;i++)
            {
                auto it=q.front();
                q.pop();
                TreeNode *cur=it.first;
                int row= it.second.first;
                int col= it.second.second;

                int exp,jump;
                if(cur->left || cur->right){
                    exp = rootHt-row-2;
                    jump = (1<<exp);
                }

                if(cur->left){
                    q.push({cur->left,  { row+1, col-jump }  });
                }
                if(cur->right){
                    q.push({cur->right, { row+1, col+jump }  });
                }

                res[row][col]= to_string(cur->val);
            }
        }
        return res;
    }
}

endsnippet


snippet snipdisp "Display contents of vector" b
namespace my{
    template<class  T>
    void display(const vector<T> &vec,string separator = " "){

        for(int i=0;i<vec.size();i++)
        {
            cout << vec[i] << separator;
        }
        cout<<endl;
    }

    template<class  T>
    void display(const vector<pair<T,T>> &vec,string separator = " "){

        for(int i=0;i<vec.size();i++)
        {
            cout <<"("<<vec[i].first<<","<<vec[i].second<<")"<< separator;
        }
        cout<<endl;
    }

    template<class  T>
    void display(const vector<vector<T>> &vec,string separator = " "){

        for(int i=0;i<vec.size();i++)
        {
            for(int j=0;j<vec[i].size();j++)
            {
                cout << vec[i][j] << separator;
            }
            cout<<endl;
        }
        cout<<endl;
    }
}
endsnippet


## Iteration
# for i
snippet fori
for (int ${2:i} = ${3:0}; $2 < ${1:count}; $2${4:++}) {
	${5:// codeblock}
}
endsnippet

# foreach
snippet fore
for (${1:auto} ${2:i} : ${3:container}) {
	${4:// codeblock}
}
endsnippet


# while
snippet whi
while (${1:condition}) {
	${2:// codeblock}
}
endsnippet


# do- while
snippet dowhi
do {
	${2:// codeblock}
} while (${1:condition}) ;

endsnippet

# try exception
snippet try
try {
    ${2:// codeblock}
}catch(${1:...}) {
    ${3:// catch block}
}
endsnippet

# if
snippet if 
if ( ${1:condition} ) {
    ${2:// codeblock}
}
endsnippet

# else if 
snippet elif 
else if ( ${1:condition} ) {
    ${2:// codeblock}
}
endsnippet

# else 
snippet el
else ( ${1:condition} ) {
    ${2:// codeblock}
}
endsnippet

# ifif
snippet ifif
if ( ${1:condition 1} ) {
    ${3:// codeblock} 
}else if( ${2:condition 2} ){
    ${4:// codeblock} 
endsnippet

# ifel
snippet ifel
if ( ${1:condition} ) {
    ${2:// codeblock}
}else{
    ${3:// codeblock}
}
endsnippet


# ififel
snippet ififel
if ( ${1:condition 1} ) {
    ${3:// codeblock} 
}else if( ${2:condition 2} ){
    ${4:// codeblock} 
}else{
    ${5:// codeblock} 
}
endsnippet

###########################################################################
#                 Vim-snippets           TextMate Snippets                            #
###########################################################################

#snippet ponce "#pragma once include guard"
##pragma once

#endsnippet

#snippet main
#int main(int argc, char *argv[])
#{
#	${0}
#	return 0;
#}
#endsnippet

#snippet forc "general for loop (for)"
#for (${6:auto} ${1:i} = ${2:v.begin()}; `!p import re; snip.rv = re.split("[^\w]",t[1])[-1]` ${4:!=} ${3:`!p m = re.search(r'^(?:(.*)(\.|->)begin\(\)|((?:std|boost)::)?begin\((.*)\))$', t[2]); snip.rv = (((m.group(3) if m.group(3) else "") + "end(" + m.group(4) + ")") if m.group(4) else (m.group(1) + m.group(2) + "end()")) if m else ""`}; ${5:++`!p snip.rv = t[1].split(" ")[-1]`}) {
#	${VISUAL}$0
#}
#endsnippet

#snippet beginend "$1.begin(), $1.end() (beginend)"
#${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
#endsnippet

#snippet cl "class .. (class)"
#class ${1:`!p snip.rv = snip.basename or "name"`}
#{
#public:
#	${1/(\w+).*/$1/} (${2:arguments});
#	virtual ~${1/(\w+).*/$1/} ();

#private:
#	${0:/* data */}
#};
#endsnippet

#snippet ns "namespace .. (namespace)"
#namespace${1/.+/ /m}${1:`!p snip.rv = snip.basename or "name"`}
#{
#	${VISUAL}$0
#}${1/.+/ \/* /m}$1${1/.+/ *\/ /m}
#endsnippet

#snippet nsa "namespace alias"
#namespace ${1:alias} = ${2:namespace};
#endsnippet

#snippet using "using directive/using declaration/type alias"
#using ${1:namespace}`!p snip.rv = ' ' if t[1] == 'namespace' else ' = ' if t[1] != '' else ''`${2:name};
#endsnippet

#snippet readfile "read file (readF)"
#std::vector<char> v;
#if (FILE *fp = fopen(${1:"filename"}, "r"))
#{
#	char buf[1024];
#	while(size_t len = fread(buf, 1, sizeof(buf), fp))
#		v.insert(v.end(), buf, buf + len);
#	fclose(fp);
#}
#endsnippet

#snippet map "std::map (map)"
#std::map<${1:key}, ${2:value}> map$0;
#endsnippet

#snippet vector "std::vector (v)"
#std::vector<${1:char}> v$0;
#endsnippet

#snippet tp "template <typename ..> (template)"
#template <typename ${1:_InputIter}>
#endsnippet

#snippet cla "An entire .h generator" b
##ifndef ${2:`!v substitute(vim_snippets#Filename('$1_H','ClassName'),'.*','\U&\E','')`}
##define $2

#class ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
#{
#private:
#	$3

#public:
#	$1();
#	virtual ~$1();
#};

##endif /* $2 */
#endsnippet


#snippet fnc "Basic c++ doxygen function template" b
#/**
#* @brief: ${4:brief}
#*
#* @param: `!p write_docstring_args(t[3],snip)`
#*
#* @return: `!p snip.rv = t[1]`
#*/
#${1:ReturnType} ${2:FunctionName}(${3:param})
#{
#	${0:FunctionBody}
#}
#endsnippet

#snippet boost_test "Boost test module" b
##define BOOST_TEST_MODULE ${1:TestModuleName}
##include <boost/test/included/unit_test.hpp>

#BOOST_AUTO_TEST_CASE(${2:TestCaseName})
#{
#	${0:TestDefinition}
#}

#endsnippet

#snippet boost_suite "Boost test suite module" b
##define BOOST_TEST_MODULE ${1:TestModuleName}
##include <boost/test/included/unit_test.hpp>

#BOOST_AUTO_TEST_SUITE(${2:SuiteName})

#BOOST_AUTO_TEST_CASE(${3:TestCaseName})
#{
#	${0:TestDefinition}
#}

#BOOST_AUTO_TEST_SUITE_END()

#endsnippet
#snippet boost_test_fixture "Boost test module with fixture" b
##define BOOST_TEST_MODULE ${1:TestModuleName}
##include <boost/test/included/unit_test.hpp>

#struct ${2:FixtureName} {
#	$2() {}
#	virtual ~$2() {}
#	/* define members here */
#};

#BOOST_FIXTURE_TEST_CASE(${3:SuiteName}, $2)
#{
#	${0:TestDefinition}
#}

#endsnippet

#snippet boost_suite_fixture "Boost test suite with fixture" b
##define BOOST_TEST_MODULE ${1:TestModuleName}
##include <boost/test/included/unit_test.hpp>

#struct ${2:FixtureName} {
#	$2() {}
#	virtual ~$2() {}
#	/* define members here */
#};

#BOOST_FIXTURE_TEST_SUITE(${3:SuiteName}, $2)

#BOOST_AUTO_TEST_CASE(${4:TestCaseName})
#{
#	${0:TestDefinition}
#}

#BOOST_AUTO_TEST_SUITE_END()

#endsnippet


## vim:ft=snippets:
